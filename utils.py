"""
Утилиты для парсинга JSON и построения промптов
"""
import json
import re
import ast
from typing import Dict, Any


def build_prompt3(text: str) -> str:
    """
    Генерация промпта для конкретного текста
    """
    return """
Ты — эксперт по извлечению численных и количественных характеристик из текстов о химических веществах и удобрениях.  
Твоя задача:  

1. Найти все численные признаки в тексте, например:  
   - Массовую долю элементов (массовая доля N, массовая доля P2O5 и др.) в процентах.  
   - Количество товара (кг, т, п/э мешки, вагон и др.).  
   - Прочие численные показатели, указанные в тексте (марки, стандарты (ТУ, ГОСТ и др.), идентификаторы).  

2. Для каждого численного признака определить:  
   - Название признака (например, "массовая доля N", "массовая доля P2O5", "массовая доля К2О", "массовая доля S", "масса нетто единицы", "масса нетто", "масса K2O", "масса брутто", "количество вагонов", "стандарт" и т.д.)  
   - Значение (число, если есть диапазон — брать оба значения; для стандарта указываешь полный номер стандарта со словами ГОСТ/ТУ или др.)  
   - Единицу измерения (%, кг, т, шт, п/э меш, вагон, или пусто для стандарта)  

3. Особые указания:
   - Извлекай на русском
   - Если признак указан как диапазон из нескольких чисел (например "8-10", или "от 6 до 12") или с погрешностью (+/-), укажи оба числа в формате [min, max]. 
   - Извлекай логические/сравнительные операторы, если они присутствуют в тексте: «не менее» - [min, null] «не более» - [null, max]
   - Используй точку в качестве разделителя десятичных чисел.
   - Название вещества и его массовая доля могут встречаться в марке (например, "N7-P20-K30-S3"),  используй данные из марки, если нет иных данных по массовой доле вещества.
   - Если в названии признака есть название химического элемента (например Кальций) - замени его на обозначение химического элемента - Ca.
   - Названия признаков пиши с маленькой буквы. Например "массовая доля Zn".
   - Если указано например "МАССОВАЯ ДОЛЯ K В ПЕРЕСЧЕТЕ НА К2О" - то правильным извлекаемым признаком будет "массовая доля K2O".
   - Если один и тот же параметр встречается дважды — сначала как общее условие (например, «с содержанием азота более 10%»), а затем как конкретное значение (например, «азот 16%»), указывай только конкретное значение.
   - Для массы с упаковкой - называй признак "масса брутто" вне зависимости от наименования упаковки. Если указывается просто масса в формате "МЕШКИ ПО 50 КГ" - это признак "масса нетто".
   - Если дается масса в виде "ПО 1000 КГ+5%" - указывай в признаке "масса брутто" одно значение - 1050.
   - Для прочих признаков (всех признаков, помимо "массовой доли") указывай единицы измерения (за исключением признаков "марка" и "стандарт")
   - Если признака в тексте нет - не извлекай его и не выводи его в json.

4 . Выводи строго JSON следующего вида (пример):

```json
{
  "массовая доля": [
    {"вещество": "N", "массовая доля": [26, 28]},
    {"вещество": "P2O5", "массовая доля": [20, null]},
    {"вещество": "K2O", "массовая доля": 20},
    {"вещество": "S", "массовая доля": 3},
    {"вещество": "NH4+", "массовая доля": [null, 2]}
  ],
  "прочее": [
    {"параметр": "масса нетто единицы", "масса": 50, "единица": "кг"},
    {"параметр": "масса брутто", "масса": 1020, "единица": "кг"},
    {"параметр": "количество поддонов", "количество": 20, "единица": "шт"},
    {"параметр": "количество мешков", "количество": 1000, "единица": "шт"},
    {"параметр": "объем нетто единицы", "объем": 10, "единица": "л"},
    {"параметр": "стандарт", "значение": "ТУ 2184-037-32496445-02"},
    {"параметр": "марка", "значение": "N7-P20-K30-S3"}
  ]
}

5. Выводи json результат **только после слова ОТВЕТ:**.

Текст для анализа:
""" + text


def _extract_json_like(s: str) -> str:
    """
    Извлекает JSON-подстроку:
    1) fenced ```json ... ```
    2) если нет — ищет первый '{' и возвращает оттуда до конца (фрагмент, возможно обрезанный)
    """
    if not isinstance(s, str):
        return ""

    # 1) fenced block ```json ... ```
    m = re.search(r"```(?:json)?\s*(.*?)\s*```", s, flags=re.IGNORECASE | re.DOTALL)
    if m:
        return m.group(1).strip()

    # убрать ведущие markdown-символы и пробелы
    s_stripped = re.sub(r"^[\s\*\-#>]+", "", s.lstrip())

    # 2) найти первую фигурную скобку и вернуть фрагмент от неё до конца (включая возможную обрезку)
    idx = s_stripped.find("{")
    if idx != -1:
        return s_stripped[idx:].strip()

    # если нет '{', пробуем '['
    idx = s_stripped.find("[")
    if idx != -1:
        return s_stripped[idx:].strip()

    return ""


def _autofix_commas(s: str) -> str:
    """
    Вставляет пропущенные запятые между соседними объектами/элементами,
    удаляет лишние запятые перед закрывающими скобками.
    """
    # "}{", "}\n{" -> "}, {"
    s = re.sub(r"}\s*{", "}, {", s)
    s = re.sub(r"}\s*\n\s*{", "},\n{", s)

    # "] {" -> "], {"
    s = re.sub(r"]\s*{", "], {", s)

    # удалить запятую перед закрывающей скобкой
    s = re.sub(r",\s*}", "}", s)
    s = re.sub(r",\s*\]", "]", s)

    return s


def _balance_and_close(s: str) -> str:
    """
    Считает незакрытые скобки и дозакрывает их в конце: сначала ']' затем '}'.
    """
    depth_obj = 0
    depth_arr = 0
    in_string = False
    escape = False

    for ch in s:
        if ch == '"' and not escape:
            in_string = not in_string
        if not in_string:
            if ch == "{":
                depth_obj += 1
            elif ch == "}":
                if depth_obj > 0:
                    depth_obj -= 1
            elif ch == "[":
                depth_arr += 1
            elif ch == "]":
                if depth_arr > 0:
                    depth_arr -= 1
        if ch == "\\" and not escape:
            escape = True
        else:
            escape = False

    # дозакрываем: сначала массивы, потом объекты
    closing = ""
    if depth_arr > 0:
        closing += "]" * depth_arr
    if depth_obj > 0:
        closing += "}" * depth_obj

    if closing:
        s = s + closing

    return s


def parse_json_safe(s: str) -> Dict[str, Any]:
    """
    Умный парсер JSON с автопочинкой и автодозакрытием скобок.
    Возвращает dict (успешно распарсенный объект) или {}.
    """
    if not isinstance(s, str) or not s.strip():
        return {}

    fragment = _extract_json_like(s)
    if not fragment:
        return {}

    s_clean = fragment.replace("\r", "").replace("\t", "").strip()

    # замены типографских кавычек
    s_clean = s_clean.replace(""", '"').replace(""", '"').replace("‚", "'").replace("'", "'")

    # нормализуем None/null
    s_clean = re.sub(r"\bNone\b", "null", s_clean)

    # автопочинки запятых
    s_clean = _autofix_commas(s_clean)

    # дозакрываем скобки
    s_clean = _balance_and_close(s_clean)

    # удалить двойные запятые
    s_clean = re.sub(r",\s*,+", ",", s_clean)

    # Попытка парсинга
    try:
        parsed = json.loads(s_clean)
        if isinstance(parsed, dict):
            return parsed
        return {}
    except json.JSONDecodeError:
        pass

    # fallback: безопасный eval
    s_eval = re.sub(r"\bnull\b", "None", s_clean)
    try:
        data = ast.literal_eval(s_eval)
        if isinstance(data, dict):
            return data
        return {}
    except Exception:
        pass

    return {}


def is_valid_json(s: str) -> bool:
    """
    Проверка валидности JSON
    """
    try:
        parsed = parse_json_safe(s)
        if not parsed:
            return False
        return isinstance(parsed, dict)
    except Exception:
        return False


def extract_json_from_response(response_text: str) -> str:
    """
    Извлекает JSON часть из ответа модели.
    Ищет:
    1. "ОТВЕТ:" или "Ответ:" (любой регистр)
    2. Markdown блоки ```json ... ```
    3. Прямой JSON в тексте
    """
    if not response_text:
        return ""
    
    # Нормализуем регистр для поиска
    response_lower = response_text.lower()
    
    # 1. Ищем "ОТВЕТ:" или "Ответ:" (любой регистр)
    answer_markers = ["ответ:", "answer:"]
    for marker in answer_markers:
        if marker in response_lower:
            # Находим позицию маркера (с учетом регистра)
            idx = response_lower.find(marker)
            if idx != -1:
                # Берем текст после маркера
                json_part = response_text[idx + len(marker):].strip()
                # Убираем возможные переносы строк и пробелы в начале
                json_part = json_part.lstrip("\n\r\t ")
                # Если после маркера сразу идет markdown блок, извлекаем его
                extracted = _extract_json_like(json_part)
                if extracted:
                    return extracted
                # Иначе возвращаем как есть (будет обработано в parse_json_safe)
                return json_part
    
    # 2. Если нет маркера "Ответ:", ищем markdown блоки ```json ... ```
    extracted = _extract_json_like(response_text)
    if extracted:
        return extracted
    
    # 3. Иначе возвращаем весь текст (будет обработано в parse_json_safe)
    return response_text.strip()

